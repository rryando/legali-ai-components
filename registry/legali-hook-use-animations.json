{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "legali-hook-use-animations",
  "type": "registry:hook",
  "files": [
    {
      "path": "components/ui/legali/hooks/useAnimations.ts",
      "content": "/**\n * @see {@link https://raw.githubusercontent.com/rryando/legali-ai-components/main/registry/legali-hook-use-animations.json} â€” Install:\n * @example npx shadcn@latest add \"https://raw.githubusercontent.com/rryando/legali-ai-components/main/registry/legali-hook-use-animations.json\"\n */\nimport { useCallback, useEffect, useRef, useState } from \"react\";\n\n/**\n * Hook to detect when an element is in viewport\n */\nexport function useInView(options?: IntersectionObserverInit) {\n  const [isInView, setIsInView] = useState(false);\n  const [hasAnimated, setHasAnimated] = useState(false);\n  const ref = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    const element = ref.current;\n    if (!element) return;\n\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        if (entry.isIntersecting) {\n          setIsInView(true);\n          if (!hasAnimated) setHasAnimated(true);\n        } else {\n          setIsInView(false);\n        }\n      },\n      { threshold: 0.1, ...options }\n    );\n\n    observer.observe(element);\n    return () => observer.disconnect();\n  }, [hasAnimated, options]);\n\n  return { ref, isInView, hasAnimated };\n}\n\n/**\n * Hook for animated counter\n */\nexport function useCountUp(target: number, duration = 2000, startOnView = true) {\n  const [count, setCount] = useState(0);\n  const [isActive, setIsActive] = useState(!startOnView);\n  const startTimeRef = useRef<number | null>(null);\n  const rafRef = useRef<number | null>(null);\n\n  const start = useCallback(() => setIsActive(true), []);\n\n  useEffect(() => {\n    if (!isActive) return;\n\n    const animate = (timestamp: number) => {\n      if (!startTimeRef.current) startTimeRef.current = timestamp;\n      const progress = Math.min((timestamp - startTimeRef.current) / duration, 1);\n\n      // Easing function (ease-out-cubic)\n      const eased = 1 - (1 - progress) ** 3;\n      setCount(Math.floor(eased * target));\n\n      if (progress < 1) {\n        rafRef.current = requestAnimationFrame(animate);\n      }\n    };\n\n    rafRef.current = requestAnimationFrame(animate);\n\n    return () => {\n      if (rafRef.current) cancelAnimationFrame(rafRef.current);\n    };\n  }, [isActive, target, duration]);\n\n  return { count, start, isActive };\n}\n\n/**\n * Hook for typing animation effect\n */\nexport function useTypingAnimation(\n  texts: string[],\n  typingSpeed = 80,\n  deletingSpeed = 40,\n  pauseDuration = 2000\n) {\n  const [displayText, setDisplayText] = useState(\"\");\n  const [textIndex, setTextIndex] = useState(0);\n  const [isTyping, setIsTyping] = useState(true);\n  const [isPaused, setIsPaused] = useState(false);\n\n  useEffect(() => {\n    const currentText = texts[textIndex];\n\n    if (isPaused) {\n      const pauseTimer = setTimeout(() => {\n        setIsPaused(false);\n        setIsTyping(false);\n      }, pauseDuration);\n      return () => clearTimeout(pauseTimer);\n    }\n\n    if (isTyping) {\n      if (displayText.length < currentText.length) {\n        const timer = setTimeout(() => {\n          setDisplayText(currentText.slice(0, displayText.length + 1));\n        }, typingSpeed);\n        return () => clearTimeout(timer);\n      }\n      setIsPaused(true);\n    } else if (displayText.length > 0) {\n      const timer = setTimeout(() => {\n        setDisplayText(displayText.slice(0, -1));\n      }, deletingSpeed);\n      return () => clearTimeout(timer);\n    } else {\n      setTextIndex((prev) => (prev + 1) % texts.length);\n      setIsTyping(true);\n    }\n  }, [\n    displayText,\n    isTyping,\n    isPaused,\n    textIndex,\n    texts,\n    typingSpeed,\n    deletingSpeed,\n    pauseDuration,\n  ]);\n\n  return displayText;\n}\n\n/**\n * Hook for idle detection\n */\nexport function useIdleDetection(timeout = 5000) {\n  const [isIdle, setIsIdle] = useState(false);\n  const timeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  useEffect(() => {\n    const resetTimer = () => {\n      if (timeoutRef.current) clearTimeout(timeoutRef.current);\n      setIsIdle(false);\n      timeoutRef.current = setTimeout(() => setIsIdle(true), timeout);\n    };\n\n    const events = [\"mousedown\", \"mousemove\", \"keydown\", \"scroll\", \"touchstart\"];\n    events.forEach((event) => window.addEventListener(event, resetTimer));\n\n    resetTimer(); // Start initial timer\n\n    return () => {\n      if (timeoutRef.current) clearTimeout(timeoutRef.current);\n      events.forEach((event) => window.removeEventListener(event, resetTimer));\n    };\n  }, [timeout]);\n\n  return isIdle;\n}\n\n/**\n * Hook for scroll progress\n */\nexport function useScrollProgress() {\n  const [progress, setProgress] = useState(0);\n\n  useEffect(() => {\n    const handleScroll = () => {\n      const scrollTop = window.scrollY;\n      const docHeight = document.documentElement.scrollHeight - window.innerHeight;\n      const scrolled = docHeight > 0 ? (scrollTop / docHeight) * 100 : 0;\n      setProgress(scrolled);\n    };\n\n    window.addEventListener(\"scroll\", handleScroll, { passive: true });\n    return () => window.removeEventListener(\"scroll\", handleScroll);\n  }, []);\n\n  return progress;\n}\n\n/**\n * Hook for current section detection\n */\nexport function useCurrentSection(sectionIds: string[]) {\n  const [currentSection, setCurrentSection] = useState<string | null>(null);\n\n  useEffect(() => {\n    const handleScroll = () => {\n      const scrollPosition = window.scrollY + window.innerHeight / 3;\n\n      for (const id of sectionIds) {\n        const element = document.getElementById(id);\n        if (element) {\n          const { offsetTop, offsetHeight } = element;\n          if (scrollPosition >= offsetTop && scrollPosition < offsetTop + offsetHeight) {\n            setCurrentSection(id);\n            return;\n          }\n        }\n      }\n    };\n\n    window.addEventListener(\"scroll\", handleScroll, { passive: true });\n    handleScroll(); // Check initial position\n    return () => window.removeEventListener(\"scroll\", handleScroll);\n  }, [sectionIds]);\n\n  return currentSection;\n}\n\n/**\n * Hook for mouse position (for cursor glow)\n */\nexport function useMousePosition() {\n  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });\n\n  useEffect(() => {\n    const handleMouseMove = (e: MouseEvent) => {\n      setMousePosition({ x: e.clientX, y: e.clientY });\n    };\n\n    window.addEventListener(\"mousemove\", handleMouseMove);\n    return () => window.removeEventListener(\"mousemove\", handleMouseMove);\n  }, []);\n\n  return mousePosition;\n}\n\n/**\n * Hook for parallax effect\n */\nexport function useParallax(speed = 0.5) {\n  const [offset, setOffset] = useState(0);\n\n  useEffect(() => {\n    const handleScroll = () => {\n      setOffset(window.scrollY * speed);\n    };\n\n    window.addEventListener(\"scroll\", handleScroll, { passive: true });\n    return () => window.removeEventListener(\"scroll\", handleScroll);\n  }, [speed]);\n\n  return offset;\n}\n\n/**\n * Hook for staggered animations\n */\nexport function useStaggeredAnimation(itemCount: number, delay = 100) {\n  const [visibleItems, setVisibleItems] = useState<number[]>([]);\n  const { ref, isInView } = useInView();\n\n  useEffect(() => {\n    if (isInView && visibleItems.length === 0) {\n      const timers: NodeJS.Timeout[] = [];\n      for (let i = 0; i < itemCount; i++) {\n        timers.push(\n          setTimeout(() => {\n            setVisibleItems((prev) => [...prev, i]);\n          }, i * delay)\n        );\n      }\n      return () => timers.forEach(clearTimeout);\n    }\n  }, [isInView, itemCount, delay, visibleItems.length]);\n\n  return { ref, visibleItems, isInView };\n}\n\n/**\n * Hook for tracking mouse position relative to an element\n */\nexport function useLocalMousePosition(ref: { current: HTMLElement | null }) {\n  const [localPosition, setLocalPosition] = useState({ x: 0, y: 0 });\n  const [isInside, setIsInside] = useState(false);\n\n  useEffect(() => {\n    const element = ref.current;\n    if (!element) {\n      return;\n    }\n\n    const handleMouseMove = (e: MouseEvent) => {\n      const rect = element.getBoundingClientRect();\n      setLocalPosition({\n        x: e.clientX - rect.left,\n        y: e.clientY - rect.top,\n      });\n    };\n\n    const handleMouseEnter = () => {\n      setIsInside(true);\n    };\n    const handleMouseLeave = () => {\n      setIsInside(false);\n    };\n\n    element.addEventListener(\"mousemove\", handleMouseMove);\n    element.addEventListener(\"mouseenter\", handleMouseEnter);\n    element.addEventListener(\"mouseleave\", handleMouseLeave);\n\n    return () => {\n      element.removeEventListener(\"mousemove\", handleMouseMove);\n      element.removeEventListener(\"mouseenter\", handleMouseEnter);\n      element.removeEventListener(\"mouseleave\", handleMouseLeave);\n    };\n  }, [ref]);\n\n  return { localPosition, isInside };\n}\n",
      "type": "registry:hook"
    }
  ]
<<<<<<< Updated upstream
}
=======
}
>>>>>>> Stashed changes
